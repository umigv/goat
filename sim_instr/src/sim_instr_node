#include "ros/ros.h"
#include "geometry_msgs/Twist.h"
#include <vector>
#include <string>
#include <fstream>
#include <sstream>


struct TimeAndCmdVel{
    ros::Duration time;
    geometry_msgs::Twist cmd_vel;
};

TimeAndCmdVel parse_line(const std::string &line_in) {
    std::istringstream line_stream(line_in);
    TimeAndCmdVel line;

    getline(line_stream, line) >> line.time >> line.cmd_vel.linear.x >> line.cmd_vel.linear.y >> line.cmd_vel.linear.z >>
        line.cmd_vel.angular.x >> line.cmd_vel.angular.y >> line.cmd_vel.angular.z;
    return line;
}


int main(int argc, char** argv) { 
    ros::init(argc, argv, "sim_instr");
    ros::NodeHandle nh("~");
    ros::Publisher pub = nh.advertise<geometry_msgs::Twist>("cmd_vel", 1000);

    std::string filename;
    do {
        bool isValidFilename = nh.getParam("filename", filename);
    } 
    while(!isValidFilename);

    std::ifstream file(filename);

    std::vector<ros::Timer> timers;
    std::vector<geometry_msgs::Twist> twists;
    std::transform(twists.cbegin(), twists.cend(), std::back_inserter(timers), [&nh](const TimeAndCmdVel &line) { ... });

    auto callback = [&pub, &twists](auto) {
    pub.publish(twists.back());
    twists.pop_back();
    };

    std::string line;
    while(file >> line) {
        TimeAndCmdVel pline = parse_line(line);
        twists.push_back(pline.cmd_vel);
    }

    for (Twist t : twists) {
        timers.push_back(nh.createTimer(ros::Duration(pline.time), callback, true));
    }
}

istream& operator >> (istream& in, string& line)
{
    line.read(ins);
    return ins;
}